<?php

/**
 * @file
 * Adds a question and answer type to the Captcha module.
 */

/**
 * Implements hook_config_info().
 */
function riddler_config_info() {
  $prefixes['riddler.settings'] = array(
    'label' => t('Captcha Riddler Settings'),
    'group' => t('Configuration'),
  );
  return $prefixes;
}

/**
 * Implements hook_permission().
 */
function riddler_permission() {
  return array(
    'administer riddler' => array(
      'title' => t('Administer Captcha Riddler'),
      'description' => t('Perform administration tasks for Captcha Riddler.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function riddler_menu() {
  $items = array();
  $items['admin/config/people/captcha/riddler'] = array(
    'title' => 'Riddler',
    'description' => 'Allows you to force a question to a number of forms to counter f.e. spammers.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('riddler_settings'),
    'access arguments' => array('administer riddler'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Settings form definition.
 */
function riddler_settings($form, &$form_state) {
  $i = 0;
  // Load the riddles either from tempstore or from config.
  if (isset($form_state['storage']['riddles'])) {
    $riddles = $form_state['storage']['riddles'];
  }
  else {
    $riddles = riddler_get_riddles();
  }
  $form = array();
  $form['#tree'] = TRUE;
  $form['riddler_weight'] = array(
    '#type' => 'number',
    '#title' => t('Weight'),
    '#default_value' => config_get('riddler.settings', 'riddler_weight'),
    '#min' => -20,
    '#max' => 20,
    '#description' => t('Weight of the Riddler form element'),
    '#required' => TRUE,
  );
  $form['riddler_groups'] = array(
    '#type' => 'fieldset',
    '#title' => t('Riddles'),
    '#prefix' => '<div id="riddler-groups">',
    '#suffix' => '</div>',
  );
  // If the add another button is clicked, add an empty array element.
  if (isset($form_state['triggering_element']) && $form_state['triggering_element']['#name'] == 'add-riddle') {
    $uuid = new Uuid();
    $key = $uuid->generate();
    $riddles[$key] = array('question' => '', 'answer' => '');
  }
  $riddler_groups = isset($form_state['values']['riddler_groups']) ? $form_state['values']['riddler_groups'] : array();
  foreach ($riddles as $key => $riddle) {
    $i++;
    $access = TRUE;
    // Is ajax rebuilding the form?
    if (isset($form_state['values'])) {
      // Is this question deleted?
      if (isset($riddler_groups[$key]['riddler_delete']) && $riddler_groups[$key]['riddler_delete']) {
        $access = FALSE;
      }
    }
    $collapse = TRUE;
    if (!empty($riddler_groups) && empty($form_state['values']['riddler_groups'][$key])) {
      $collapse = FALSE;
    }
    $title = t('Riddle') . ' ' . $i . ': ' . $riddle['question'];
    if (isset($riddler_groups[$key]) && !empty($riddler_groups[$key]['riddler_question'])) {
      $title = t('Riddle') . ' ' . $i . ': ' . $riddler_groups[$key]['riddler_question'];
    }
    $form['riddler_groups'][$key] = array(
      '#type' => 'fieldset',
      '#title' => $title,
      '#collapsible' => TRUE,
      '#collapsed' => $collapse,
      '#access' => $access,
    );
    $form['riddler_groups'][$key]['riddler_question'] = array(
      '#type' => 'textfield',
      '#title' => t('Question'),
      '#description' => t('A question that you require anonymous users to answer'),
      '#default_value' => isset($riddler_groups[$key]['riddler_question']) ? $riddler_groups[$key]['riddler_question'] : $riddle['question'],
      '#required' => FALSE,
      '#access' => $access,
    );
    $form['riddler_groups'][$key]['riddler_answer'] = array(
      '#type' => 'textfield',
      '#title' => t('Answer'),
      '#default_value' => isset($riddler_groups[$key]['riddler_answer']) ? $riddler_groups[$key]['riddler_answer'] : $riddle['answer'],
      '#description' => t('Answer to the above question. You may allow more than one correct answer by entering a comma or space-separated list. Answers are not case sensitive.  Answers must be only one word.'),
      '#access' => $access,
      '#required' => FALSE,
    );
    $form['riddler_groups'][$key]['riddler_delete'] = array(
      '#type' => 'checkbox',
      '#title' => t('Delete'),
      '#description' => t('Permanently delete this riddle/answer pair?'),
      '#required' => FALSE,
      '#default_value' => isset($riddler_groups[$key]['riddler_delete']) ? $riddler_groups[$key]['riddler_delete'] : FALSE,
      '#ajax' => array(
        'callback' => 'riddler_ajax_add_riddle',
        'wrapper' => 'riddler-groups',
        'method' => 'replace',
        'effect' => 'fade',
        '#access' => $access,
      ),
    );
  }
  $form['riddler_groups']['riddler_add'] = array(
    '#type' => 'button',
    '#value' => t('Add another'),
    '#name' => 'add-riddle',
    '#ajax' => array(
      'callback' => 'riddler_ajax_add_riddle',
      'wrapper' => 'riddler-groups',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );
  // Use tempstore to park already added values.
  $form_state['storage']['riddles'] = $riddles;
  $form['#validate'][] = 'riddler_settings_validate';
  $form['#submit'][] = 'riddler_settings_submit';
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save settings'),
  );
  return $form;
}

/**
 * Riddler settings form ajax callback.
 */
function riddler_ajax_add_riddle(&$form, &$form_state) {
  return $form['riddler_groups'];
}

/**
 * Validate the settings form.
 */
function riddler_settings_validate($form, &$form_state) {
  $i = 1;
  unset($form_state['values']['riddler_groups']['riddler_add']);
  $riddler_groups = $form_state['values']['riddler_groups'];
  foreach ($riddler_groups as $uuid => $values) {
    $i++;
    if ($values['riddler_question'] != '' && $values['riddler_answer'] == '') {
      $element = "riddler_groups[{$uuid}][riddler_answer]";
      form_set_error($element, t('Riddle !i is incomplete (answer is missing).', array('!i' => $i)));
    }
    if ($values['riddler_question'] == '' && $values['riddler_answer'] != '') {
      $element = "riddler_groups[{$uuid}][riddler_question]";
      form_set_error($element, t('Riddle !i is incomplete (question is missing).', array('!i' => $i)));
    }
    // Unset any completely empty riddle/answer pairs.
    if ($riddler_groups[$uuid]['riddler_question'] == '' && $riddler_groups[$uuid]['riddler_answer'] == '') {
      unset($form_state['values']['riddler_groups'][$uuid]);
    }
  }
}

/**
 * Submit the settings form.
 */
function riddler_settings_submit($form, &$form_state) {
  $riddler_questions = array();
  $translatables = array();
  $riddler_groups = $form_state['values']['riddler_groups'];
  foreach ($riddler_groups as $uuid => $values) {
    // Make sure pair is not deleted.
    if (!$values['riddler_delete']) {
      $riddler_questions[$uuid] = array(
        'question' => $values['riddler_question'],
        'answer' => $values['riddler_answer'],
      );
      $translatables[] = "riddler_questions.{$uuid}.question";
      $translatables[] = "riddler_questions.{$uuid}.answer";
      // @todo We might need to trigger locale to pick these up?
    }
  }
  $config = config('riddler.settings');
  $config->set('_config_translatables', $translatables);
  $config->set('riddler_weight', $form_state['values']['riddler_weight']);
  $config->set('riddler_questions', $riddler_questions);
  $config->save();
  backdrop_set_message(t('Riddler settings saved.'), 'status');
}

/**
 * Implements hook_captcha().
 */
function riddler_captcha($op, $captcha_type = '') {
  switch ($op) {
    case 'list':
      return array('Riddler');

    case 'generate':
      if ($captcha_type == 'Riddler') {
        // @todo translatable question / answer.
        $result = array();
        $riddles = riddler_get_riddles();
        $key = array_rand($riddles);
        $question = config_get_translated('riddler.settings', "riddler_questions.{$key}.question");
        $solution = config_get_translated('riddler.settings', "riddler_questions.{$key}.answer");
        $result['form']['captcha_response'] = array(
          '#type' => 'textfield',
          '#title' => filter_xss($question),
          '#description' => t('Fill in the blank.'),
          '#size' => 50,
          '#maxlength' => 50,
          '#required' => TRUE,
          '#weight' => config_get('riddler.settings', 'riddler_weight'),
        );
        $result['solution'] = filter_xss((string) (backdrop_strtolower($solution)));
        $result['captcha_validate'] = 'riddler_captcha_validate';
        return $result;
      }
      break;

  }
}

/**
 * Custom captcha validation.
 *
 * @param string $solution
 *   Comma-separated string of acceptable answers.
 * @param string $response
 *   User enter answer to match agains solution.
 *
 * @return bool
 *   TRUE if the response is found in the solution, or FALSE.
 */
function riddler_captcha_validate($solution, $response) {
  $solution = str_ireplace(',', ' ', $solution);
  $solution = explode(' ', $solution);
  return in_array(backdrop_strtolower($response), $solution);
}

/**
 * Load riddles from config.
 */
function riddler_get_riddles() {
  $riddles = config_get('riddler.settings', 'riddler_questions');
  return !empty($riddles) ? $riddles : array();
}
